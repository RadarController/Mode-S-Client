<!doctype html>
<html>
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  :root{
    --blue:#1e6dff;
    --panel: rgba(18,22,28,.72);
    --stroke: rgba(255,255,255,.12);
    --text: rgba(233,238,247,.94);
    --muted: rgba(233,238,247,.72);
  }
  html,body{width:1080px;height:160px;margin:0;background:transparent;overflow:hidden;font-family:Inter,system-ui,Segoe UI,Roboto,Arial,sans-serif;}
  .bar{
    width:100%;height:100%;
    display:flex;align-items:center;justify-content:space-between;
    padding: 0 22px; box-sizing:border-box;
    background: var(--panel);
    border-bottom: 1px solid var(--stroke);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
  }
  .left{display:flex;align-items:center;gap:14px;min-width:0;}
  .live{
    display:flex;align-items:center;gap:10px;
    padding:10px 14px;border-radius:16px;
    border:1px solid rgba(255,255,255,.14);
    background: rgba(10,14,18,.35);
  }
  .pulse{
    width:10px;height:10px;border-radius:50%;
    background: rgba(30,109,255,.98);
    box-shadow: 0 0 0 0 rgba(30,109,255,.55);
    animation: pulse 1.2s infinite;
  }
  @keyframes pulse{
    0%{ box-shadow:0 0 0 0 rgba(30,109,255,.55); }
    70%{ box-shadow:0 0 0 12px rgba(30,109,255,0); }
    100%{ box-shadow:0 0 0 0 rgba(30,109,255,0); }
  }
  .livetxt{font-size:14px;font-weight:900;letter-spacing:.14em;text-transform:uppercase;color:var(--text);}
  .titlewrap{display:flex;flex-direction:column;gap:4px;min-width:0;}
  .title{font-size:18px;font-weight:900;letter-spacing:.10em;text-transform:uppercase;color:var(--text);white-space:nowrap;overflow:hidden;text-overflow:ellipsis;}
  .sub{font-size:14px;color:var(--muted);white-space:nowrap;overflow:hidden;text-overflow:ellipsis;}

  .right{display:flex;gap:14px;align-items:center;}
  .stat{
    display:flex;align-items:center;gap:10px;
    padding:10px 14px;border-radius:16px;
    border:1px solid rgba(255,255,255,.14);
    background: rgba(10,14,18,.35);
    min-width: 170px;
    justify-content:center;
  }
  .dot{width:8px;height:8px;border-radius:50%;background:rgba(30,109,255,.9);}
  .label{font-size:12px;font-weight:900;letter-spacing:.14em;text-transform:uppercase;color:var(--muted);}
  .val{font-size:18px;font-weight:950;color:var(--text);min-width:60px;text-align:left;}

  /* small connection hint (optional) */
  .conn{
    position:absolute; right:22px; top:12px;
    font-size:11px; letter-spacing:.10em; text-transform:uppercase;
    color: rgba(233,238,247,.55);
  }
</style>
</head>
<body>
  <div class="bar">
    <div class="left">
      <div class="live"><span class="pulse"></span><span class="livetxt">LIVE</span></div>
      <div class="titlewrap">
        <div class="title">MANCHESTER ATC</div>
        <div class="sub">LIVE VATSIM ATC</div>
      </div>
    </div>

    <div class="right">
      <div class="stat"><span class="dot"></span><span class="label">VIEWERS</span><span class="val" id="viewers">0</span></div>
      <div class="stat"><span class="dot"></span><span class="label">FOLLOWERS</span><span class="val" id="followers">0</span></div>
    </div>
  </div>

  <div class="conn" id="conn">CONNECTING</div>

<script>
  // ====== CONFIG ======
  // Set these to match your Streamer.bot WebSocket Server
  const SB_WS_HOST = "127.0.0.1";
  const SB_WS_PORT = 8080; // change if your Streamer.bot uses a different port
  // ====================

  const elView = document.getElementById("viewers");
  const elFoll = document.getElementById("followers");
  const elConn = document.getElementById("conn");

  const sleep = (ms)=>new Promise(r=>setTimeout(r,ms));
  const toNumber = (v)=> {
    const n = Number(String(v ?? "").replace(/[^\d.-]/g,""));
    return Number.isFinite(n) ? n : 0;
  };
  const fmt = (n)=>Math.round(n).toLocaleString(undefined);

  function makeAnimator(el){
    return { el, current:0, target:0, last:null,
      setTarget(v){ this.target = Math.max(0, toNumber(v)); },
      tick(){
        const d = this.target - this.current;
        if (Math.abs(d) < 0.05) this.current = this.target;
        else this.current += d * 0.18;
        const t = fmt(this.current);
        if (t !== this.last){ this.el.textContent = t; this.last = t; }
      }
    };
  }
  const aV = makeAnimator(elView);
  const aF = makeAnimator(elFoll);
  (function raf(){ aV.tick(); aF.tick(); requestAnimationFrame(raf); })();

  // Expected incoming messages (JSON), any of these keys:
  // { "totalViewers": 123, "totalFollowers": 4567 }
  function handleMessage(obj){
    if (!obj || typeof obj !== "object") return;
    if (obj.totalViewers !== undefined) aV.setTarget(obj.totalViewers);
    if (obj.totalFollowers !== undefined) aF.setTarget(obj.totalFollowers);
  }

  async function connect(){
    try{
      elConn.textContent = "CONNECTING";
      const ws = new WebSocket(`ws://${SB_WS_HOST}:${SB_WS_PORT}`);

      ws.onopen = () => { elConn.textContent = "CONNECTED"; };
      ws.onclose = async () => {
        elConn.textContent = "RECONNECTING";
        await sleep(1500);
        connect();
      };
      ws.onerror = () => { elConn.textContent = "WS ERROR"; };

      ws.onmessage = (ev) => {
        // Some websocket servers send plain JSON, others wrap it. We handle both.
        try{
          const msg = JSON.parse(ev.data);

          // If Streamer.bot sends a wrapper, try to unwrap common shapes:
          // { event: "...", data: {...} } OR { d: {...} }
          if (msg && typeof msg === "object") {
            if (msg.data && typeof msg.data === "object") handleMessage(msg.data);
            else if (msg.d && typeof msg.d === "object") handleMessage(msg.d);
            else handleMessage(msg);
          }
        }catch(_){}
      };
    }catch(_){
      elConn.textContent = "FAILED";
      await sleep(1500);
      connect();
    }
  }

  connect();
</script>
</body>
</html>
