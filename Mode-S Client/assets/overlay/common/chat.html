<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Chat</title>
    <style>
        /* Minimal styling to ensure the log is scrollable in OBS browser sources */
        html, body { margin: 0; padding: 0; height: 100%; background: transparent; overflow: hidden; }
        body { font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, Arial, sans-serif; color: #fff; }
        /* Make the log take full viewport width and be scrollable vertically. Hide scrollbars visually but keep scrolling. */
        #log { padding: 8px; overflow-y: auto; height: 100vh; box-sizing: border-box; width: 100vw; scroll-behavior: smooth; }
        #log .line { margin: 2px 0; display: flex; align-items: flex-start; }
        #log .icon { width: 20px; height: 20px; flex: 0 0 20px; margin-right: 8px; }
        #log .text { white-space: normal; word-break: break-word; flex: 1 1 auto; }
        #log .user { font-weight: 600; margin-right: 6px; }

        /* Hide scrollbar for WebKit-based browsers */
        #log::-webkit-scrollbar { width: 0px; height: 0px; display: none; }
        /* Hide scrollbar for Firefox */
        #log { scrollbar-width: none; }
        /* Hide scrollbar for IE, Edge */
        #log { -ms-overflow-style: none; }
    </style>
</head>
<body>
    <div id="log"></div>

    <script>
        const LOG = document.getElementById("log");

        const ENDPOINTS = [
            "/api/chat?limit=200",
            "/api/chat/recent?limit=200",
            "/api/chat",
            "/api/chat/recent"
        ];

        const POLL_MS = 500;
        const MAX_LINES = 250;

        // Dedupe because "recent" endpoints usually return a rolling window each poll.
        const seen = new Set();
        const seenQueue = [];
        const SEEN_LIMIT = 5000;

        // Preload icons from several candidate locations. If none available, use embedded fallbacks.
        const ICONS = { twitch: null, tiktok: null };

        async function tryLoadIconCandidates(name, candidates) {
            for (const p of candidates) {
                try {
                    const res = await fetch(p, { cache: 'no-store' });
                    if (res.ok) {
                        const txt = await res.text();
                        return txt;
                    }
                } catch (e) {
                    // ignore and try next
                }
            }
            return null;
        }

        async function preloadIcons() {
            const twitchCandidates = ['./icons/twitch-icon.svg','/overlay/icons/twitch-icon.svg','/assets/icons/twitch-icon.svg','/icons/twitch-icon.svg'];
            const tiktokCandidates = ['./icons/tiktok-icon.svg','/overlay/icons/tiktok-icon.svg','/assets/icons/tiktok-icon.svg','/icons/tiktok-icon.svg'];
            ICONS.twitch = await tryLoadIconCandidates('twitch', twitchCandidates);
            ICONS.tiktok = await tryLoadIconCandidates('tiktok', tiktokCandidates);
        }

        function pick(obj, keys, fallback = "") {
            if (!obj || typeof obj !== "object") return fallback;
            for (const k of keys) {
                const v = obj[k];
                if (v !== undefined && v !== null && String(v).length) return v;
            }
            return fallback;
        }

        function normalize(raw) {
            const m = (raw && raw.data && typeof raw.data === "object") ? raw.data : raw;
            const platform = String(pick(m, ["platform","source","service","provider","origin"], "chat")).toLowerCase();
            const user = String(pick(m, ["user","username","display_name","nick","author","name"], ""));
            const text = String(pick(m, ["message","text","content","msg","body"], ""));
            const ts = pick(m, ["ts_ms","timestamp","ts","time","created_at"], Date.now());
            const color = String(pick(m, ["color","user_color"], ""));
            const id = String(pick(m, ["id","message_id","msg_id","uuid"], platform + "|" + user + "|" + ts + "|" + text));
            return { platform, user, text, ts, id, color, raw: m };
        }

        function remember(id) {
            if (!id) return false;
            if (seen.has(id)) return false;
            seen.add(id);
            seenQueue.push(id);
            if (seenQueue.length > SEEN_LIMIT) {
                const drop = seenQueue.shift();
                seen.delete(drop);
            }
            return true;
        }

        function iconFor(platform) {
            platform = (platform || '').toLowerCase();
            const span = document.createElement('span');
            span.className = 'icon';
            if (platform.indexOf('twitch') === 0 && ICONS.twitch) { span.innerHTML = ICONS.twitch; return span; }
            if (platform.indexOf('tiktok') === 0 && ICONS.tiktok) { span.innerHTML = ICONS.tiktok; return span; }
            if (platform.indexOf('twitch') === 0) { span.innerHTML = '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path fill="#6441A4" d="M4 4h16v11H8l-4 4V4z"/></svg>'; }
            else if (platform.indexOf('tiktok') === 0) { span.innerHTML = '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path fill="#25F4EE" d="M16 3v9.5A3.5 3.5 0 1 1 13 9V7l3-4z"/><path fill="#FE2C55" d="M16 3v6.5A3.5 3.5 0 1 0 13 6V3h3z" opacity="0.9"/></svg>'; }
            else if (platform.indexOf('youtube') === 0) { span.innerHTML = '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path fill="#FF0000" d="M10 8l6 4-6 4z"/><rect x="3" y="6" width="18" height="12" rx="2" ry="2" fill="none" stroke="#FF0000" stroke-width="1"/></svg>'; }
            else { const letter = (platform && platform[0]) ? platform[0].toUpperCase() : '?'; span.innerHTML = `<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><circle cx="12" cy="12" r="10" fill="#666"/><text x="12" y="16" font-size="10" text-anchor="middle" fill="#fff" font-family="Arial, sans-serif">${letter}</text></svg>`; }
            return span;
        }

        function addLine(n) {
            if (!n.text) return;
            const line = document.createElement('div'); line.className = 'line';
            const icon = iconFor(n.platform); line.appendChild(icon);

            const txt = document.createElement('div'); txt.className = 'text';
            // username span (colored for twitch if available)
            const userSpan = document.createElement('span');
            userSpan.className = 'user';
            userSpan.textContent = n.user;
            if (n.platform && n.platform.indexOf('twitch') === 0 && n.color) {
                try { userSpan.style.color = n.color; } catch (e) { /* ignore invalid color */ }
            }
            txt.appendChild(userSpan);

            const msgSpan = document.createElement('span');
            msgSpan.textContent = ': ' + n.text;
            txt.appendChild(msgSpan);

            line.appendChild(txt);
            LOG.appendChild(line);
            while (LOG.childNodes.length > MAX_LINES) LOG.removeChild(LOG.firstChild);
            // Smooth scroll new line into view
            try { line.scrollIntoView({ behavior: 'smooth', block: 'end' }); } catch (e) { LOG.scrollTop = LOG.scrollHeight; }
        }

        async function fetchFirstWorkingEndpoint() {
            let lastErr = null;
            for (const url of ENDPOINTS) {
                try {
                    const res = await fetch(url, { cache: "no-store" });
                    if (!res.ok) throw new Error(`${url} -> HTTP ${res.status}`);
                    const data = await res.json();
                    return { url, data };
                } catch (e) { lastErr = e; }
            }
            throw lastErr || new Error("No endpoints tried");
        }

        function extractMessages(data) {
            if (Array.isArray(data)) return data;
            if (data && Array.isArray(data.messages)) return data.messages;
            if (data && Array.isArray(data.items)) return data.items;
            return [];
        }

        async function poll() {
            try {
                const { url, data } = await fetchFirstWorkingEndpoint();
                const msgs = extractMessages(data);
                if (!msgs.length) return;
                let serverNewestTs = 0; let added = 0;
                for (const raw of msgs) {
                    const n = normalize(raw);
                    try { const t = Number(n.ts) || 0; if (t > serverNewestTs) serverNewestTs = t; } catch (e) {}
                    if (!n.text) continue;
                    if (remember(n.id)) { addLine(n); added++; }
                }
                // no page reload; DOM updates with smooth scroll are used
            } catch (e) {
                console.error('chat poll error:', e);
            }
        }

        (async () => { await preloadIcons(); window.addEventListener('load', () => { if (LOG.lastElementChild) LOG.lastElementChild.scrollIntoView(); }); poll(); setInterval(poll, POLL_MS); })();
    </script>
</body>
</html>