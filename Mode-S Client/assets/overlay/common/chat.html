<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Chat</title>
</head>
<body>
    <div id="status">connecting…</div>
    <div id="log"></div>
    <pre id="payload" style="display:none"></pre>

    <script>
        const STATUS = document.getElementById("status");
        const LOG = document.getElementById("log");
        const PAYLOAD = document.getElementById("payload");

        const ENDPOINTS = [
            "/api/chat?limit=200",
            "/api/chat/recent?limit=200",
            "/api/chat",
            "/api/chat/recent"
        ];

        const POLL_MS = 500;
        const MAX_LINES = 250;

        // Dedupe because "recent" endpoints usually return a rolling window each poll.
        const seen = new Set();
        const seenQueue = [];
        const SEEN_LIMIT = 5000;

        function setStatus(s) { STATUS.textContent = s; }

        function pick(obj, keys, fallback = "") {
            if (!obj || typeof obj !== "object") return fallback;
            for (const k of keys) {
                const v = obj[k];
                if (v !== undefined && v !== null && String(v).length) return v;
            }
            return fallback;
        }

        function normalize(raw) {
            // unwrap {data:{...}} if needed
            const m = (raw && raw.data && typeof raw.data === "object") ? raw.data : raw;

            const platform = String(pick(m, ["platform", "source", "service", "provider", "origin"], "chat")).toLowerCase();
            const user = String(pick(m, ["user", "username", "display_name", "nick", "author", "name"], ""));
            const text = String(pick(m, ["message", "text", "content", "msg", "body"], ""));
            const ts = pick(m, ["ts_ms", "timestamp", "ts", "time", "created_at"], Date.now());

            // If you don’t provide an id, create a stable-enough key
            const id = String(pick(m, ["id", "message_id", "msg_id", "uuid"], platform + "|" + user + "|" + ts + "|" + text));

            return { platform, user, text, ts, id, raw: m };
        }

        function remember(id) {
            if (!id) return false;
            if (seen.has(id)) return false;
            seen.add(id);
            seenQueue.push(id);
            if (seenQueue.length > SEEN_LIMIT) {
                const drop = seenQueue.shift();
                seen.delete(drop);
            }
            return true;
        }

        function addLine(n) {
            if (!n.text) return; // nothing to render

            const line = document.createElement("div");
            line.textContent = `[${(n.platform || "CHAT").toUpperCase()}] ${n.user}: ${n.text}`;
            LOG.appendChild(line);

            while (LOG.childNodes.length > MAX_LINES) {
                LOG.removeChild(LOG.firstChild);
            }
        }

        async function fetchFirstWorkingEndpoint() {
            let lastErr = null;

            for (const url of ENDPOINTS) {
                try {
                    const res = await fetch(url, { cache: "no-store" });
                    if (!res.ok) throw new Error(`${url} -> HTTP ${res.status}`);
                    const data = await res.json();
                    return { url, data };
                } catch (e) {
                    lastErr = e;
                }
            }

            throw lastErr || new Error("No endpoints tried");
        }

        function extractMessages(data) {
            // Accept:
            //  - { messages: [...] }
            //  - [...] (array)
            //  - { items: [...] }
            if (Array.isArray(data)) return data;
            if (data && Array.isArray(data.messages)) return data.messages;
            if (data && Array.isArray(data.items)) return data.items;
            return [];
        }

        async function poll() {
            try {
                const { url, data } = await fetchFirstWorkingEndpoint();

                PAYLOAD.textContent = JSON.stringify(data, null, 2);
                console.log("chat poll from:", url, data);

                const msgs = extractMessages(data);

                if (!msgs.length) {
                    setStatus(`live (0 messages from ${url})`);
                    return;
                }

                let added = 0;
                for (const raw of msgs) {
                    const n = normalize(raw);
                    if (!n.text) continue;
                    if (remember(n.id)) {
                        addLine(n);
                        added++;
                    }
                }

                setStatus(`live (${added} new)`);
            } catch (e) {
                console.error("chat poll error:", e);
                setStatus("error (retrying)");
            }
        }

        poll();
        setInterval(poll, POLL_MS);
    </script>
</body>
</html>
