<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Chat</title>
    <style>
        /* Minimal styling to ensure the log is scrollable in OBS browser sources */
        html, body {
            margin: 0;
            padding: 0;
            height: 100%;
            background: transparent;
            overflow: hidden;
        }

        body {
            font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, Arial, sans-serif;
            color: #fff;
        }
        /* Make the log take full viewport width and be scrollable vertically. Hide scrollbars visually but keep scrolling. */
        #log {
            padding: 8px;
            overflow-y: auto;
            height: 100vh;
            box-sizing: border-box;
            width: 100vw;
            scroll-behavior: smooth;
            scrollbar-width: none;
            -ms-overflow-style: none;
        }

            #log .line {
                min-height: 20px;
                margin: 2px 0;
                display: flex;
                align-items: flex-start;
            }

            #log .icon {
                width: 20px;
                height: 20px;
                flex: 0 0 20px;
                margin-right: 8px;
            }

                #log .icon svg {
                    width: 100% !important;
                    height: 100% !important;
                    display: block !important;
                }

            #log .text {
                white-space: normal;
                word-break: break-word;
                flex: 1 1 auto;
            }

            /* Remove extra horizontal gap on the username so the colon added in JS produces a single space: "username: message" */
            #log .user {
                font-weight: 600;
                margin-right: 0;
            }

            /* Hide scrollbar for WebKit-based browsers */
            #log::-webkit-scrollbar {
                width: 0px;
                height: 0px;
                display: none;
            }

        /* Base line styling */
        .line {
            border-left: 4px solid transparent;
            padding-left: 10px;
        }

        /* Twitch */
        .platform-twitch .user {
            color: #9146FF;
        }

        .platform-twitch.line {
            border-left-color: #9146FF;
        }

        /* TikTok */
        .platform-tiktok .user {
            color: #25F4EE;
        }

        .platform-tiktok.line {
            border-left-color: #25F4EE;
        }

        /* YouTube */
        .platform-youtube .user {
            color: #FF0000;
        }

        .platform-youtube.line {
            border-left-color: #FF0000;
        }

        /* --- Event styling (no rail, no background pills) --- */
        @keyframes eventIn {
            from {
                opacity: 0;
                transform: translateY(2px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .line.event {
            position: relative;
            animation: eventIn 140ms cubic-bezier(.2,.8,.2,1);
            font-weight: 850;
            letter-spacing: 0.02em;
            text-transform: none;
            /* spacing so the glass has room */
            padding: 8px;
            margin: 3px 0;
            border-radius: 0 12px 12px 0;
            /* "glass" background: not a solid pill */
            background: rgba(255,255,255,0.06);
            box-shadow: inset 0 1px 0 rgba(255,255,255,0.10), inset 0 -1px 0 rgba(0,0,0,0.25), 0 10px 18px rgba(0,0,0,0.18);
            /* keep legibility */
            text-shadow: 0 1px 16px rgba(0,0,0,0.45);
            backdrop-filter: blur(6px);
            -webkit-backdrop-filter: blur(6px);
        }
            /* Subtle platform tint via a soft ambient wash */
            .line.event::before {
                content: "";
                position: absolute;
                inset: 0;
                border-radius: 12px;
                pointer-events: none;
                opacity: 0.22; /* keep this low to avoid tacky */
                mix-blend-mode: screen;
            }

        .line.event.platform-twitch::before {
            background: radial-gradient(120% 140% at 0% 50%, rgba(145,70,255,0.55), rgba(145,70,255,0.00) 60%);
        }

        .line.event.platform-youtube::before {
            background: radial-gradient(120% 140% at 0% 50%, rgba(255,0,51,0.55), rgba(255,0,51,0.00) 60%);
        }

        .line.event.platform-tiktok::before {
            background: radial-gradient(120% 140% at 0% 50%, rgba(0,242,234,0.55), rgba(0,242,234,0.00) 60%);
        }

        /* Optional: platform hint ONLY on glyph (clean, not blocky) */
        .line.event.platform-twitch .event-prefix {
            color: #cdb7ff;
        }

        .line.event.platform-youtube .event-prefix {
            color: #ffb3c1;
        }

        .line.event.platform-tiktok .event-prefix {
            color: #b7fff9;
        }
    </style>
    <script src="/assets/mergedChatFeed.js"></script>
</head>
<body>
    <div id="log"></div>
    <!-- <div id="diag" style="
      position: fixed;
      left: 8px;
      bottom: 8px;
      font: 12px/1.2 monospace;
      background: rgba(255,255,255,0.85);
      padding: 6px 8px;
      border-radius: 6px;
      z-index: 9999;
      max-width: 70vw;
      white-space: pre;
    "></div>-->

    <script>
        const LOG = document.getElementById("log");

        const DIAG = document.getElementById('diag');
        const DEBUG_ENABLED = false;

        const dbg = {
            received: 0,
            rendered: 0,
            skip_empty: 0,
            skip_dupe: 0,
            skip_other: 0,
            appended_without_icon: 0,
            appended_without_text: 0,
            lastSkip: "",
            lastAppendWarn: ""
        };

        function setDiag() {
            if (!DEBUG_ENABLED || !DIAG) return;
            DIAG.textContent =
                `recv=${dbg.received}  rend=${dbg.rendered}
                                skip_empty=${dbg.skip_empty}  skip_dupe=${dbg.skip_dupe}  skip_other=${dbg.skip_other}
                                warn_no_icon=${dbg.appended_without_icon}  warn_no_text=${dbg.appended_without_text}
                                lastSkip=${dbg.lastSkip}
                                lastWarn=${dbg.lastAppendWarn}`;
        }

        function extractGateText(n) {
            const runs = Array.isArray(n?.runs) ? n.runs : null;
            const baseText =
                (n?.text !== undefined && n?.text !== null) ? String(n.text) :
                    (n?.message !== undefined && n?.message !== null) ? String(n.message) :
                        "";

            let gate = "";
            if (runs && runs.length) {
                for (const run of runs) {
                    if (!run || typeof run !== "object") continue;
                    if (run.t === "text" && typeof run.text === "string") gate += run.text;
                    else if (run.t === "emoji" && typeof run.shortcut === "string") gate += run.shortcut;
                    else if (run.t === "emoji" && typeof run.url === "string" && run.url.length) gate += "ðŸ™‚";
                }
            } else {
                gate = baseText;
            }
            return gate;
        }

        const ENDPOINTS = [
            "/api/chat?limit=200",
            "/api/chat/recent?limit=200",
            "/api/chat",
            "/api/chat/recent"
        ];

        const POLL_MS = 500;
        const MAX_LINES = 250;

        // Dedupe because "recent" endpoints usually return a rolling window each poll.
        const seen = new Set();
        const seenQueue = [];
        const SEEN_LIMIT = 5000;

        // Preload icons from several candidate locations. If none available, use embedded fallbacks.
        // âœ… Added youtube slot.
        const ICONS = { twitch: null, tiktok: null, youtube: null };

        async function tryLoadIconCandidates(name, candidates) {
            for (const p of candidates) {
                try {
                    const res = await fetch(p, { cache: 'no-store' });
                    if (res.ok) {
                        const txt = await res.text();
                        return txt;
                    }
                } catch (e) {
                    // ignore and try next
                }
            }
            return null;
        }

        async function preloadIcons() {
            // âœ… Prefer /assets/icons first (your requirement), keep other candidates as fallbacks.
            const twitchCandidates = ['/assets/icons/twitch-icon.svg', './icons/twitch-icon.svg', '/overlay/icons/twitch-icon.svg', '/icons/twitch-icon.svg'];
            const tiktokCandidates = ['/assets/icons/tiktok-icon.svg', './icons/tiktok-icon.svg', '/overlay/icons/tiktok-icon.svg', '/icons/tiktok-icon.svg'];
            const youtubeCandidates = ['/assets/icons/youtube-icon.svg', './icons/youtube-icon.svg', '/overlay/icons/youtube-icon.svg', '/icons/youtube-icon.svg'];

            ICONS.twitch = await tryLoadIconCandidates('twitch', twitchCandidates);
            ICONS.tiktok = await tryLoadIconCandidates('tiktok', tiktokCandidates);
            ICONS.youtube = await tryLoadIconCandidates('youtube', youtubeCandidates);
        }

        function pick(obj, keys, fallback = "") {
            if (!obj || typeof obj !== "object") return fallback;
            for (const k of keys) {
                const v = obj[k];
                if (v !== undefined && v !== null && String(v).length) return v;
            }
            return fallback;
        }

        function normalize(raw) {
            const m = (raw && raw.data && typeof raw.data === "object") ? raw.data : raw;
            const platform = String(pick(m, ["platform", "source", "service", "provider", "origin"], "chat")).toLowerCase();
            const user = String(pick(m, ["user", "username", "display_name", "nick", "author", "name"], ""));
            const text = String(pick(m, ["message", "text", "content", "msg", "body"], ""));
            const ts = pick(m, ["ts_ms", "timestamp", "ts", "time", "created_at"], Date.now());
            const color = String(pick(m, ["color", "user_color"], ""));
            let id = String(pick(m, ["id", "message_id", "msg_id", "uuid"], platform + "|" + user + "|" + ts + "|" + text));

            // Stronger dedupe for YouTube: sometimes the same message can arrive twice
            // (one path with emoji runs, one without). Use a stable signature ID.
            if (platform === "youtube") {
                id = platform + "|" + user + "|" + ts + "|" + text;
            }

            const runs = (m && Array.isArray(m.runs)) ? m.runs : null;
            const is_event = !!m.is_event;
            return { platform, user, text, ts, id, color, runs, raw: m, is_event };
        }

        function normalizeEvent(raw) {
            const e = (raw && raw.data && typeof raw.data === "object") ? raw.data : raw;
            const platform = String(pick(e, ["platform"], "twitch")).toLowerCase() || "twitch";
            const type = String(pick(e, ["type"], "event"));
            const user = String(pick(e, ["user", "username", "display_name", "name"], ""));
            const msg = String(pick(e, ["message", "text"], type));
            const ts = pick(e, ["ts_ms", "timestamp", "ts", "time", "created_at"], Date.now());
            const id = "event|" + platform + "|" + type + "|" + user + "|" + ts + "|" + msg;
            return { platform, user, text: msg, ts, id, color: "", raw: e, is_event: true, event_type: type };
        }

        async function fetchEventsSafe() {
            try {
                const r = await fetch("/api/twitch/eventsub/events?limit=200", { cache: "no-store" });
                if (!r.ok) return { count: 0, events: [] };
                return await r.json();
            } catch (_) {
                return { count: 0, events: [] };
            }
        }
        async function fetchTikTokEventsSafe() {
            try {
                const r = await fetch("/api/tiktok/events?limit=200", { cache: "no-store" });

                if (!r.ok) return [];
                const j = await r.json();
                const evs = Array.isArray(j?.events) ? j.events : [];
                return evs;
            } catch (e) {
                return [];
            }
        }

        function remember(id) {
            if (!id) return false;
            if (seen.has(id)) return false;
            seen.add(id);
            seenQueue.push(id);
            if (seenQueue.length > SEEN_LIMIT) {
                const drop = seenQueue.shift();
                seen.delete(drop);
            }
            return true;
        }
        // Deterministic color generator from username
        function colorFromName(name) {
            if (!name) return '';
            // simple hash
            let h = 2166136261 >>> 0;
            for (let i = 0; i < name.length; i++) {
                h ^= name.charCodeAt(i);
                h = Math.imul(h, 16777619) >>> 0;
            }
            // map to hue 0-360
            const hue = h % 360;
            // pick saturation & lightness suitable for readable username colors
            const sat = 60;
            const light = 50;
            return `hsl(${hue} ${sat}% ${light}%)`;
        }

        function iconFor(platform) {
            platform = (platform || '').toLowerCase();
            const span = document.createElement('span');
            span.className = 'icon';

            if (platform.indexOf('twitch') === 0 && ICONS.twitch) { span.innerHTML = ICONS.twitch; return span; }
            if (platform.indexOf('tiktok') === 0 && ICONS.tiktok) { span.innerHTML = ICONS.tiktok; return span; }
            // âœ… Added youtube icon usage
            if (platform.indexOf('youtube') === 0 && ICONS.youtube) { span.innerHTML = ICONS.youtube; return span; }

            // Fallbacks if SVG files can't be loaded for some reason
            if (platform.indexOf('twitch') === 0) { span.innerHTML = '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path fill="#6441A4" d="M4 4h16v11H8l-4 4V4z"/></svg>'; }
            else if (platform.indexOf('tiktok') === 0) { span.innerHTML = '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path fill="#25F4EE" d="M16 3v9.5A3.5 3.5 0 1 1 13 9V7l3-4z"/><path fill="#FE2C55" d="M16 3v6.5A3.5 3.5 0 1 0 13 6V3h3z" opacity="0.9"/></svg>'; }
            else if (platform.indexOf('youtube') === 0) { span.innerHTML = '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path fill="#FF0000" d="M10 8l6 4-6 4z"/><rect x="3" y="6" width="18" height="12" rx="2" ry="2" fill="none" stroke="#FF0000" stroke-width="1"/></svg>'; }
            else { const letter = (platform && platform[0]) ? platform[0].toUpperCase() : '?'; span.innerHTML = `<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><circle cx="12" cy="12" r="10" fill="#666"/><text x="12" y="16" font-size="10" text-anchor="middle" fill="#fff" font-family="Arial, sans-serif">${letter}</text></svg>`; }

            return span;
        }

        function addLine(n) {
            dbg.received++;

            if (!n) {
                dbg.lastSkip = "n was null/undefined";
                setDiag();
                return;
            }

            // --- DUPLICATE CHECK (keeps your existing behaviour if you have seen/ids) ---
            // If your file already has a "seen" set somewhere, KEEP USING IT.
            // If it does not, this block is harmless and you can delete it later.
            window.__seen = window.__seen || new Set();
            const id = n.id || `${n.platform}|${n.user}|${n.ts_ms}|${extractGateText(n).slice(0, 40)}`;
            if (window.__seen.has(id)) {
                dbg.skip_dupe++;
                dbg.lastSkip = `dupe id=${id}`;
                setDiag();
                return;
            }
            window.__seen.add(id);
            // --- /DUPLICATE CHECK ---

            // Gate: if it will render as empty, do not append anything (prevents icon drift)
            const gate = extractGateText(n);
            if (gate.replace(/\u200B/g, "").trim().length === 0) {
                dbg.skip_empty++;
                dbg.lastSkip = `empty gate platform=${n.platform || "?"}`;
                setDiag();
                return;
            }

            // Build the line DOM (icon + text are appended together)
            const line = document.createElement('div');
            line.className = 'line';

            const platRaw = (n.platform || '').toLowerCase();
            const plat = platRaw.split(':')[0]; // strip ":event"
            if (plat) line.classList.add(`platform-${plat}`);

            if (n.is_event) line.classList.add('event');

            const icon = iconFor(n.platform);
            line.appendChild(icon);

            const txt = document.createElement('div');
            txt.className = 'text';

            // user
            // Event prefix (only for events)
            if (n.is_event) {
                const p = document.createElement('span');
                p.className = 'event-prefix';
                txt.appendChild(p);
            }

            const userSpan = document.createElement("span");
            userSpan.className = "user";

            const name = String(n.user || "").trim();
            userSpan.textContent = name;

            // Prefer platform/native colour if provided (Twitch IRC), otherwise fall back
            const userColor = String(n.color || n.user_color || "").trim();
            if (userColor && userColor.startsWith("#")) {
                userSpan.style.color = userColor;
            } else if (name) {
                userSpan.style.color = colorFromName(name);
            }

            txt.appendChild(userSpan);

            // message
            const msgSpan = document.createElement('span');

            // Normal chat: "User: message"
            // Event: "â—ˆ User message"
            if (!n.is_event) {
                msgSpan.appendChild(document.createTextNode(': '));
            } else {
                msgSpan.appendChild(document.createTextNode(' '));
            }

            const runs = Array.isArray(n.runs) ? n.runs : null;
            const baseText =
                (n.text !== undefined && n.text !== null) ? String(n.text) :
                    (n.message !== undefined && n.message !== null) ? String(n.message) :
                        "";

            let appended = false;

            if (runs && runs.length) {
                for (const run of runs) {
                    if (!run || typeof run !== 'object') continue;

                    if (run.t === 'text' && typeof run.text === 'string') {
                        if (run.text.length) appended = true;
                        msgSpan.appendChild(document.createTextNode(run.text));
                    } else if (run.t === 'emoji') {
                        const shortcut = (typeof run.shortcut === 'string') ? run.shortcut : '';
                        if (typeof run.url === 'string' && run.url.length) {
                            const img = document.createElement('img');
                            img.className = 'yt-emoji';
                            img.src = run.url;
                            img.alt = shortcut || 'emoji';
                            img.loading = 'lazy';
                            msgSpan.appendChild(img);
                            appended = true;
                        } else if (shortcut) {
                            msgSpan.appendChild(document.createTextNode(shortcut));
                            appended = true;
                        }
                    } else if (run.t === 'mention' && typeof run.text === 'string') {
                        // Defensive if mentions exist
                        if (run.text.length) appended = true;
                        msgSpan.appendChild(document.createTextNode(run.text));
                    }
                }
            }

            if (!appended && baseText) {
                msgSpan.appendChild(document.createTextNode(baseText));
            }

            txt.appendChild(msgSpan);
            line.appendChild(txt);

            // Append
            LOG.appendChild(line);
            dbg.rendered++;

            // Sanity checks â€” if these rise, we found the exact failure mode
            const iconEl = line.querySelector('.icon, img.platform, svg');
            const textEl = line.querySelector('.text');
            if (!iconEl) {
                dbg.warn_no_icon++;
                dbg.lastWarn = `NO ICON platform=${n.platform || "?"}`;
            }
            if (!textEl || textEl.textContent.replace(/\u200B/g, "").trim().length === 0) {
                dbg.warn_no_text++;
                dbg.lastWarn = `NO TEXT platform=${n.platform || "?"}`;
            }

            // keep within MAX_LINES (uses your existing constant)
            while (LOG.childNodes.length > MAX_LINES) LOG.removeChild(LOG.firstChild);

            setDiag();

            // scroll
            try {
                line.scrollIntoView({ behavior: 'smooth', block: 'end' });
            } catch (e) {
                LOG.scrollTop = LOG.scrollHeight;
            }
        }

        async function fetchFirstWorkingEndpoint() {
            let lastErr = null;
            for (const url of ENDPOINTS) {
                try {
                    const res = await fetch(url, { cache: "no-store" });
                    if (!res.ok) throw new Error(`${url} -> HTTP ${res.status}`);
                    const data = await res.json();
                    return { url, data };
                } catch (e) { lastErr = e; }
            }
            throw lastErr || new Error("No endpoints tried");
        }

        function extractMessages(data) {
            if (Array.isArray(data)) return data;
            if (data && Array.isArray(data.messages)) return data.messages;
            if (data && Array.isArray(data.items)) return data.items;
            return [];
        }

        async function poll() {
            // This function is kept for compatibility, but the actual work is delegated
            // to the shared MergedChatFeed module.
        }

        // ---- merged chat + EventSub events feed ----
        let __mergedFeedTimer = null;
        function startMergedFeed() {
            if (__mergedFeedTimer) clearInterval(__mergedFeedTimer);

            __mergedFeedTimer = MergedChatFeed.start({
                intervalMs: 1000,
                maxItems: 200,
                dedupeWindowMs: 5000,
                includeEvents: false,

                // Chat fetch returns the JSON used by this page.
                fetchChat: async () => {
                    const r = await fetchFirstWorkingEndpoint();
                    return r.data ?? r;
                },

                // Event fetch returns {count, events:[...]}
                fetchEvents: async () => {
                    const [tw, tt] = await Promise.all([
                        fetchEventsSafe(),
                        fetchTikTokEventsSafe()
                    ]);
                    const twEvents = (tw && tw.events) ? tw.events : (tw || []);
                    const ttEvents = (tt && tt.events) ? tt.events : (tt || []);
                    return { count: (twEvents.length + ttEvents.length), events: [...twEvents, ...ttEvents] };
                },

                // Convert chat JSON into raw message items.
                extractChatItems: (chatJson) => extractMessages(chatJson),

                // Normalize chat raw item into a common shape
                normalizeChatItem: (raw) => {
                    const n = normalize(raw);
                    if (!n) return n;
                    return n;
                },

                // Normalize EventSub event into a common shape
                normalizeEventItem: (raw) => normalizeEvent(raw),

                remember,
                addLine,

                onError: (e) => {
                    // Keep overlay quiet; app can log to console
                    if (typeof console !== "undefined" && console.error) console.error("merged feed error:", e);
                }
            });
        }

        // âœ… Ensure icons are loaded before the feed begins rendering lines.
        preloadIcons()
            .catch(() => { })  // fall back to inline SVGs if icon files can't be fetched
            .finally(() => startMergedFeed());

        // setDiag();


    </script>
</body>
</html>