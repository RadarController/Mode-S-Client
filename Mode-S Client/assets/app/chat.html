<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Chat</title>
    <style>
        /* Minimal styling to ensure the log is scrollable in OBS browser sources */
        html, body { margin: 0; padding: 0; height: 100%; background: transparent; overflow: hidden; }
        body { font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, Arial, sans-serif; color: #000; }
        /* Make the log take full viewport width and be scrollable vertically. Hide scrollbars visually but keep scrolling. */
        #log { padding: 8px; overflow-y: auto; height: 100vh; box-sizing: border-box; width: 100vw; scroll-behavior: smooth; }
        #log .line { margin: 2px 0; display: flex; align-items: flex-start; }
            #log .line {
                margin: 2px 0;
                display: flex;
                align-items: flex-start;
            }

            #log .icon {
                width: 20px;
                height: 20px;
                flex: 0 0 20px;
                margin-right: 8px;
            }
                /* ðŸ”§ Normalize inline SVG icon sizing */
                #log .icon svg {
                    width: 100%;
                    height: 100%;
                    display: block;
                }
        #log .text { white-space: normal; word-break: break-word; flex: 1 1 auto; }
        /* Remove extra horizontal gap on the username so the colon added in JS produces a single space: "username: message" */
        #log .user { font-weight: 600; margin-right: 0; }

        /* Hide scrollbar for WebKit-based browsers */
        #log::-webkit-scrollbar { width: 0px; height: 0px; display: none; }
        /* Hide scrollbar for Firefox */
        #log { scrollbar-width: none; }
        /* Hide scrollbar for IE, Edge */
        #log { -ms-overflow-style: none; }
    
        /* Event alert styling (EventSub merged into chat feed) */
        .line.event {
            background: #025492;
            color: #fff;
            border-radius: 10px;
            padding: 4px 6px;
        }
        .line.event .text, .line.event .text span, .line.event .user {
            color: #fff !important;
        }
    
</style>
  <script src="/assets/mergedChatFeed.js"></script>
</head>
<body>
    <div id="log"></div>

    <script>
        const LOG = document.getElementById("log");

        const ENDPOINTS = [
            "/api/chat?limit=200",
            "/api/chat/recent?limit=200",
            "/api/chat",
            "/api/chat/recent"
        ];

        const POLL_MS = 500;
        const MAX_LINES = 250;

        // Dedupe because "recent" endpoints usually return a rolling window each poll.
        const seen = new Set();
        const seenQueue = [];
        const SEEN_LIMIT = 5000;

        // Preload icons from several candidate locations. If none available, use embedded fallbacks.
        const ICONS = { twitch: null, tiktok: null };

        async function tryLoadIconCandidates(name, candidates) {
            for (const p of candidates) {
                try {
                    const res = await fetch(p, { cache: 'no-store' });
                    if (res.ok) {
                        const txt = await res.text();
                        return txt;
                    }
                } catch (e) {
                    // ignore and try next
                }
            }
            return null;
        }

        async function preloadIcons() {
            const twitchCandidates = ['./icons/twitch-icon.svg','/overlay/icons/twitch-icon.svg','/assets/icons/twitch-icon.svg','/icons/twitch-icon.svg'];
            const tiktokCandidates = ['./icons/tiktok-icon.svg','/overlay/icons/tiktok-icon.svg','/assets/icons/tiktok-icon.svg','/icons/tiktok-icon.svg'];
            ICONS.twitch = await tryLoadIconCandidates('twitch', twitchCandidates);
            ICONS.tiktok = await tryLoadIconCandidates('tiktok', tiktokCandidates);
        }

        function pick(obj, keys, fallback = "") {
            if (!obj || typeof obj !== "object") return fallback;
            for (const k of keys) {
                const v = obj[k];
                if (v !== undefined && v !== null && String(v).length) return v;
            }
            return fallback;
        }

        function normalize(raw) {
            const m = (raw && raw.data && typeof raw.data === "object") ? raw.data : raw;
            const platform = String(pick(m, ["platform","source","service","provider","origin"], "chat")).toLowerCase();
            const user = String(pick(m, ["user","username","display_name","nick","author","name"], ""));
            const text = String(pick(m, ["message","text","content","msg","body"], ""));
            const ts = pick(m, ["ts_ms","timestamp","ts","time","created_at"], Date.now());
            const color = String(pick(m, ["color","user_color"], ""));
            const id = String(pick(m, ["id","message_id","msg_id","uuid"], platform + "|" + user + "|" + ts + "|" + text));
            return { platform, user, text, ts, id, color, raw: m, is_event: false };
        }

        function normalizeEvent(raw) {
            const e = (raw && raw.data && typeof raw.data === "object") ? raw.data : raw;
            const platform = String(pick(e, ["platform"], "twitch")).toLowerCase() || "twitch";
            const type = String(pick(e, ["type"], "event"));
            const user = String(pick(e, ["user","username","display_name","name"], ""));
            const msg = String(pick(e, ["message","text"], type));
            const ts = pick(e, ["ts_ms","timestamp","ts","time","created_at"], Date.now());
            const id = "event|" + platform + "|" + type + "|" + user + "|" + ts + "|" + msg;
            return { platform, user, text: msg, ts, id, color: "", raw: e, is_event: true, event_type: type };
        }

        async function fetchEventsSafe() {
            try {
                const r = await fetch("/api/twitch/eventsub/events?limit=200", { cache: "no-store" });
            if (!r.ok) return { count: 0, events: [] };
            return await r.json();
        } catch (_) {
            return { count: 0, events: [] };
        }
        }
        async function fetchTikTokEventsSafe() {
            try {
                const r = await fetch("/api/tiktok/events?limit=200", { cache: "no-store" });

                if (!r.ok) return [];
                const j = await r.json();
                const evs = Array.isArray(j?.events) ? j.events : [];
                return evs;
            } catch (e) {
                return [];
            }
        }

        function remember(id) {
            if (!id) return false;
            if (seen.has(id)) return false;
            seen.add(id);
            seenQueue.push(id);
            if (seenQueue.length > SEEN_LIMIT) {
                const drop = seenQueue.shift();
                seen.delete(drop);
            }
            return true;
        }
// Deterministic color generator from username
        function colorFromName(name) {
            if (!name) return '';
            // simple hash
            let h = 2166136261 >>> 0;
            for (let i = 0; i < name.length; i++) {
                h ^= name.charCodeAt(i);
                h = Math.imul(h, 16777619) >>> 0;
            }
            // map to hue 0-360
            const hue = h % 360;
            // pick saturation & lightness suitable for readable username colors
            const sat = 60;
            const light = 50;
            return `hsl(${hue} ${sat}% ${light}%)`;
        }

        function iconFor(platform) {
            platform = (platform || '').toLowerCase();
            const span = document.createElement('span');
            span.className = 'icon';
            if (platform.indexOf('twitch') === 0 && ICONS.twitch) { span.innerHTML = ICONS.twitch; return span; }
            if (platform.indexOf('tiktok') === 0 && ICONS.tiktok) { span.innerHTML = ICONS.tiktok; return span; }
            if (platform.indexOf('twitch') === 0) { span.innerHTML = '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path fill="#6441A4" d="M4 4h16v11H8l-4 4V4z"/></svg>'; }
            else if (platform.indexOf('tiktok') === 0) { span.innerHTML = '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path fill="#25F4EE" d="M16 3v9.5A3.5 3.5 0 1 1 13 9V7l3-4z"/><path fill="#FE2C55" d="M16 3v6.5A3.5 3.5 0 1 0 13 6V3h3z" opacity="0.9"/></svg>'; }
            else if (platform.indexOf('youtube') === 0) { span.innerHTML = '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path fill="#FF0000" d="M10 8l6 4-6 4z"/><rect x="3" y="6" width="18" height="12" rx="2" ry="2" fill="none" stroke="#FF0000" stroke-width="1"/></svg>'; }
            else { const letter = (platform && platform[0]) ? platform[0].toUpperCase() : '?'; span.innerHTML = `<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><circle cx="12" cy="12" r="10" fill="#666"/><text x="12" y="16" font-size="10" text-anchor="middle" fill="#fff" font-family="Arial, sans-serif">${letter}</text></svg>`; }
            return span;
        }

        function addLine(n) {
            if (!n.text) return;
            const line = document.createElement('div'); line.className = 'line';
            if (n.is_event) line.classList.add('event');
            const icon = iconFor(n.platform); line.appendChild(icon);

            const txt = document.createElement('div'); txt.className = 'text';
            // username span (colored for twitch if available, otherwise deterministic fallback)
            const userSpan = document.createElement('span');
            userSpan.className = 'user';
            userSpan.textContent = n.user;
            if (n.is_event) { try { userSpan.style.color = '#fff'; } catch (e) {} }
            if (!n.is_event && n.platform && n.platform.indexOf('twitch') === 0) {
                const provided = (n.color || '').trim();
                const col = provided || colorFromName(n.user);
                try { userSpan.style.color = col; } catch (e) { /* ignore invalid color */ }
            }
            txt.appendChild(userSpan);

            const msgSpan = document.createElement('span');
            msgSpan.textContent = ': ' + n.text;
            txt.appendChild(msgSpan);

            line.appendChild(txt);
            LOG.appendChild(line);
            while (LOG.childNodes.length > MAX_LINES) LOG.removeChild(LOG.firstChild);
            // Smooth scroll new line into view
            try { line.scrollIntoView({ behavior: 'smooth', block: 'end' }); } catch (e) { LOG.scrollTop = LOG.scrollHeight; }
        }

        async function fetchFirstWorkingEndpoint() {
            let lastErr = null;
            for (const url of ENDPOINTS) {
                try {
                    const res = await fetch(url, { cache: "no-store" });
                    if (!res.ok) throw new Error(`${url} -> HTTP ${res.status}`);
                    const data = await res.json();
                    return { url, data };
                } catch (e) { lastErr = e; }
            }
            throw lastErr || new Error("No endpoints tried");
        }

        function extractMessages(data) {
            if (Array.isArray(data)) return data;
            if (data && Array.isArray(data.messages)) return data.messages;
            if (data && Array.isArray(data.items)) return data.items;
            return [];
        }

        async function poll() {
    // This function is kept for compatibility, but the actual work is delegated
    // to the shared MergedChatFeed module.
}




    

// ---- merged chat + EventSub events feed ----
let __mergedFeedTimer = null;
function startMergedFeed() {
    if (__mergedFeedTimer) clearInterval(__mergedFeedTimer);

    __mergedFeedTimer = MergedChatFeed.start({
        intervalMs: 1000,
        maxItems: 200,
        dedupeWindowMs: 5000,

        // Chat fetch returns the JSON used by this page.
        fetchChat: async () => {
            const r = await fetchFirstWorkingEndpoint();
            return r.data ?? r;
        },

        // Event fetch returns {count, events:[...]}
        fetchEvents: async () => {
    const [tw, tt] = await Promise.all([
        fetchEventsSafe(),
        fetchTikTokEventsSafe()
    ]);
    const twEvents = (tw && tw.events) ? tw.events : (tw || []);
    const ttEvents = (tt && tt.events) ? tt.events : (tt || []);
    return { count: (twEvents.length + ttEvents.length), events: [...twEvents, ...ttEvents] };
},

        // Convert chat JSON into raw message items.
        extractChatItems: (chatJson) => extractMessages(chatJson),

        // Normalize chat raw item into a common shape
        normalizeChatItem: (raw) => {
            const n = normalize(raw);
            if (!n) return n;
            n.is_event = false;
            return n;
        },

        // Normalize EventSub event into a common shape
        normalizeEventItem: (raw) => normalizeEvent(raw),

        remember,
        addLine,

        onError: (e) => {
            // Keep overlay quiet; app can log to console
            if (typeof console !== "undefined" && console.error) console.error("merged feed error:", e);
        }
    });
}

startMergedFeed();

</script>
</body>
</html>