<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Bot Commands</title>
  <link rel="stylesheet" href="/app/app.css" />
  <style>
    /* Minimal page-specific styling (the rest comes from app.css) */
    .statusMsg{font-size:12px;color:var(--muted)}
    .statusMsg.good{color:#9f9}
    .statusMsg.bad{color:#f99}
    .input.small{max-width:130px}
    .testGrid{display:grid;grid-template-columns:160px 180px 1fr auto;gap:10px;align-items:end}
    .testFlags{display:flex;gap:14px;align-items:center;flex-wrap:wrap;margin-top:10px}
    @media (max-width: 900px){.testGrid{grid-template-columns:1fr;}}
    .testOut{margin-top:10px;font-size:12px;color:var(--muted);white-space:pre-wrap}
  </style>
</head>
<body>
  <div class="app">
    <header class="topbar">
      <div class="brand">
        <div class="brand__mark">
          <img src="/assets/icons/RClogo.svg" alt="RadarController" style="width:100%;height:100%;display:block;opacity:0.8;border-radius:inherit;" />
        </div>
        <div class="brand__text">
          <div class="brand__title">RadarController</div>
          <div class="brand__subtitle">Mode‑S Client</div>
        </div>
      </div>

      <div class="topbar__metrics" style="justify-content:flex-start">
        <div class="pill"><span class="pill__k">Page</span><span class="pill__v">Bot Commands</span></div>
      </div>

      <div class="topbar__actions">
        <button class="btn btn--ghost" id="btnBack">Back</button>
        <button class="btn btn--ghost" id="btnReload">Reload</button>
        <button class="btn btn--ghost" id="btnAdd">Add command</button>
        <button class="btn btn--primary" id="btnSave">Save</button>
      </div>
    </header>

    <main class="grid grid--single">
      <section class="card">
        <div class="card__head">
          <div class="card__title">Bot Commands</div>
          <div class="card__hint">
            Controls the overlay-only chatbot (responses are injected into <span class="mono">/api/chat</span> for now). Commands are matched without the leading <span class="mono">!</span> and are case-insensitive.
            Placeholders: <span class="mono">{user}</span>, <span class="mono">{platform}</span>.
          </div>
        </div>

        <div style="padding:12px">
          <div class="toolbar" style="margin-bottom:10px">
            <span id="status" class="statusMsg toolbar__spacer"></span>
          </div>

          <div class="card" style="margin-bottom:12px;padding:12px;border:1px solid rgba(255,255,255,0.08);">
            <div style="font-weight:600;margin-bottom:8px;">Safety settings</div>
            <div class="grid" style="grid-template-columns:180px 180px 180px 1fr;gap:10px;align-items:end;">
              <label>
                <div class="label">Per-user gap (ms)</div>
                <input class="input" id="setUserGap" type="number" min="0" max="600000" value="3000" />
              </label>
              <label>
                <div class="label">Per-platform gap (ms)</div>
                <input class="input" id="setPlatformGap" type="number" min="0" max="600000" value="1000" />
              </label>
              <label>
                <div class="label">Max reply length</div>
                <input class="input" id="setMaxReplyLen" type="number" min="0" max="2000" value="400" />
              </label>
              <label class="pill" style="cursor:pointer;user-select:none;justify-self:start;">
                <input id="setSilentMode" type="checkbox" style="margin-right:8px;vertical-align:middle;" />
                <span class="pill__k">Mode</span><span class="pill__v">Silent</span>
              </label>
            </div>
            <div style="margin-top:8px;font-size:12px;color:var(--muted)">
              Silent mode disables bot replies without rebuilding (commands still match/preview via test).
            </div>
          </div>

          <table id="tbl" class="table">
    <thead>
      <tr>
        <th style="width:160px;">Command</th>
        <th>Response</th>
        <th style="width:140px;">Cooldown (s)</th>
        <th style="width:130px;">Scope</th>
        <th style="width:90px;">Enabled</th>
        <th style="width:70px;"></th>
      </tr>
    </thead>
    <tbody></tbody>
  </table>

<script>
  const statusEl = document.getElementById('status');
  const tbody = document.querySelector('#tbl tbody');

  const inpUserGap = document.getElementById('setUserGap');
  const inpPlatformGap = document.getElementById('setPlatformGap');
  const inpMaxReplyLen = document.getElementById('setMaxReplyLen');
  const chkSilentMode = document.getElementById('setSilentMode');

  function setStatus(text, ok=true) {
    statusEl.textContent = text;
    statusEl.classList.toggle('good', ok);
    statusEl.classList.toggle('bad', !ok);
  }

  function rowTemplate(cmd={command:'', response:'', cooldown_ms:3000, cooldown_s:null, enabled:true, scope:'all'}) {
    const cooldownMs = Number.isFinite(cmd.cooldown_ms) ? cmd.cooldown_ms : null;
    const cooldownS = Number.isFinite(cmd.cooldown_s) ? cmd.cooldown_s : (cooldownMs!=null ? Math.round(cooldownMs/1000) : 3);
    const scope = (cmd.scope||'all').toLowerCase();
    const tr = document.createElement('tr');
    tr.innerHTML = `
      <td><input class="input" type="text" placeholder="help" value="${escapeHtml(cmd.command||'')}"></td>
      <td><textarea class="input textarea" placeholder="Your response">${escapeHtml(cmd.response||'')}</textarea></td>
      <td><input class="input small" type="number" min="0" max="600" value="${Number.isFinite(cooldownS)?cooldownS:3}"></td>
      <td>
        <select class="input">
          <option value="all" ${scope==='all'?'selected':''}>All users</option>
          <option value="mods" ${scope==='mods'?'selected':''}>Mods only</option>
          <option value="broadcaster" ${scope==='broadcaster'?'selected':''}>Broadcaster only</option>
        </select>
      </td>
      <td style="text-align:center;"><input type="checkbox" ${cmd.enabled? 'checked':''}></td>
      <td><button class="btn btn--danger btnDel" type="button">Delete</button></td>
    `;
    tr.querySelector('.btnDel').addEventListener('click', () => tr.remove());
    return tr;
  }

  function escapeHtml(s) {
    return (s+'').replaceAll('&','&amp;').replaceAll('<','&lt;').replaceAll('>','&gt;').replaceAll('"','&quot;');
  }

  function collect() {
    const rows = [...tbody.querySelectorAll('tr')];
    const out = [];
    for (const r of rows) {
      const command = r.querySelector('td:nth-child(1) input').value.trim();
      const response = r.querySelector('td:nth-child(2) textarea').value;
      const cooldown_s = parseInt(r.querySelector('td:nth-child(3) input').value||'3', 10);
      const scope = (r.querySelector('td:nth-child(4) select').value||'all').toLowerCase();
      const enabled = r.querySelector('td:nth-child(5) input[type=checkbox]').checked;
      if (!command) continue;
      const cs = isFinite(cooldown_s) ? Math.max(0, Math.min(600, cooldown_s)) : 3;
      out.push({ command, response, cooldown_ms: cs*1000, enabled, scope });
    }
    return out;
  }

  async function load() {
    setStatus('Loading...');
    tbody.innerHTML = '';
    try {
      await loadSettings();
      const res = await fetch('/api/bot/commands', { cache: 'no-store' });
      const j = await res.json();
      const cmds = (j && j.commands) ? j.commands : [];
      for (const c of cmds) tbody.appendChild(rowTemplate(c));
      if (!cmds.length) tbody.appendChild(rowTemplate());
      setStatus('Loaded', true);
    } catch (e) {
      setStatus('Load failed: ' + e, false);
    }
  }

  function clampNum(v, lo, hi, fallback){
    const n = parseInt(v, 10);
    if (!isFinite(n)) return fallback;
    return Math.max(lo, Math.min(hi, n));
  }

  function collectSettings(){
    return {
      per_user_gap_ms: clampNum(inpUserGap.value, 0, 600000, 3000),
      per_platform_gap_ms: clampNum(inpPlatformGap.value, 0, 600000, 1000),
      max_reply_len: clampNum(inpMaxReplyLen.value, 0, 2000, 400),
      silent_mode: !!(chkSilentMode && chkSilentMode.checked)
    };
  }

  async function loadSettings(){
    try {
      const res = await fetch('/api/bot/settings', { cache: 'no-store' });
      const j = await res.json();
      const s = (j && j.settings) ? j.settings : {};
      if (inpUserGap) inpUserGap.value = clampNum(s.per_user_gap_ms, 0, 600000, 3000);
      if (inpPlatformGap) inpPlatformGap.value = clampNum(s.per_platform_gap_ms, 0, 600000, 1000);
      if (inpMaxReplyLen) inpMaxReplyLen.value = clampNum(s.max_reply_len, 0, 2000, 400);
      if (chkSilentMode) chkSilentMode.checked = !!s.silent_mode;
    } catch (_) {
      // keep defaults
    }
  }

  async function saveSettings(){
    const settings = collectSettings();
    const res = await fetch('/api/bot/settings', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ settings })
    });
    if (!res.ok) throw new Error('HTTP ' + res.status);
    return res.json().catch(() => ({}));
  }

  async function save() {
    setStatus('Saving...');
    try {
      await saveSettings();
      const commands = collect();
      const res = await fetch('/api/bot/commands', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ commands })
      });
      if (!res.ok) throw new Error('HTTP ' + res.status);
      await load();
      setStatus('Saved', true);
    } catch (e) {
      setStatus('Save failed: ' + e, false);
    }
  }

  document.getElementById('btnReload').addEventListener('click', load);
  document.getElementById('btnAdd').addEventListener('click', () => tbody.appendChild(rowTemplate()));
  document.getElementById('btnSave').addEventListener('click', save);
  document.getElementById('btnBack').addEventListener('click', () => {
    window.location.href = '/app/index.html';
  });

  load();
</script>
          </div>
      </section>

      <section class="card">
        <div class="card__head">
          <div class="card__title">Test (no live stream needed)</div>
          <div class="card__hint">
            This injects a fake user message and bot reply into the local chat feed so you can see it immediately in <span class="mono">/app/chat.html</span> and <span class="mono">/overlay/chat.html</span>. It does not post to Twitch/YouTube/TikTok.
          </div>
        </div>

        <div style="padding:12px">
          <div class="testGrid">
            <label>
              <div class="label">User</div>
              <input class="input" id="testUser" type="text" value="TestUser" />
            </label>

            <label>
              <div class="label">Platform</div>
              <input class="input" id="testPlatform" type="text" value="twitch" />
            </label>

            <label>
              <div class="label">Message</div>
              <input class="input" id="testMessage" type="text" placeholder="!help" />
            </label>

            <button class="btn btn--primary" id="btnRunTest" type="button">Run test</button>
          </div>

          <div class="testFlags">
            <label class="pill" style="cursor:pointer;user-select:none;">
              <input id="testIsMod" type="checkbox" style="margin-right:8px;vertical-align:middle;" />
              <span class="pill__k">Role</span><span class="pill__v">Mod</span>
            </label>
            <label class="pill" style="cursor:pointer;user-select:none;">
              <input id="testIsBroadcaster" type="checkbox" style="margin-right:8px;vertical-align:middle;" />
              <span class="pill__k">Role</span><span class="pill__v">Broadcaster</span>
            </label>
          </div>

          <div id="testOut" class="testOut"></div>
        </div>
      </section>

      <script>
        (function(){
          const out = document.getElementById('testOut');
          const inpUser = document.getElementById('testUser');
          const inpPlatform = document.getElementById('testPlatform');
          const inpMsg = document.getElementById('testMessage');
          const chkMod = document.getElementById('testIsMod');
          const chkBroadcaster = document.getElementById('testIsBroadcaster');
          const btn = document.getElementById('btnRunTest');

          function normalizeCommand(s){
            s = (s||'').trim();
            if (!s.startsWith('!')) return null;
            s = s.slice(1);
            if (!s) return null;
            const parts = s.split(/\s+/);
            return { cmd: (parts[0]||'').toLowerCase(), args: parts.slice(1) };
          }

          function applyPlaceholders(text, user, platform){
            return (text||'')
              .replaceAll('{user}', user)
              .replaceAll('{platform}', platform);
          }

          async function run(){
            const user = (inpUser.value||'').trim() || 'User';
            const platform = (inpPlatform.value||'').trim() || 'platform';
            const msg = (inpMsg.value||'').trim();
            const is_mod = !!(chkMod && chkMod.checked);
            const is_broadcaster = !!(chkBroadcaster && chkBroadcaster.checked);
            const parsed = normalizeCommand(msg);
            if (!parsed){
              out.textContent = 'Enter a command message starting with ! (e.g. !help)';
              return;
            }

            // Persist any unsaved edits first so the server test uses the same command set.
            try {
              await save();
            } catch (_) {
              // save() already reports status; still attempt a test with whatever is currently stored on the server.
            }

            try {
              const res = await fetch('/api/bot/test', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ platform, user, message: msg, is_mod, is_broadcaster })
              });
              const j = await res.json().catch(() => ({}));
              if (!res.ok) throw new Error(`HTTP ${res.status}`);

              if (j.matched) {
                out.textContent = `Injected into chat feed.\nMatched: !${j.command}\nReply: ${j.reply || ''}`;
              } else {
                const note = j.note ? ` (${j.note})` : '';
                out.textContent = `Injected user message, but no bot reply for !${parsed.cmd}${note}`;
              }
            } catch (e) {
              out.textContent = 'Test failed: ' + e;
            }
          }

          btn.addEventListener('click', run);
          inpMsg.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') { e.preventDefault(); run(); }
          });
        })();
      </script>
    </main>

    <footer class="footer">
      <div class="footer__left">Local UI at <span class="mono">/app</span> (served by the built‑in HTTP server).</div>
      <div class="footer__right"><span class="mono">Bot config</span></div>
    </footer>
  </div>
</body>
</html>
